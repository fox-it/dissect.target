from __future__ import annotations

from typing import TYPE_CHECKING

from dissect.target.exceptions import UnsupportedPluginError
from dissect.target.helpers.descriptor_extensions import UserRecordDescriptorExtension
from dissect.target.helpers.record import TargetRecordDescriptor, create_extended_descriptor
from dissect.target.plugin import Plugin, export

if TYPE_CHECKING:
    from collections.abc import Iterator

    from dissect.target.helpers.record import DynamicDescriptor
    from dissect.target.target import Target

PowershellScriptblockRecord = TargetRecordDescriptor(
    "filesystem/windows/logs/powershell/scriptblock",
    [
        ("datetime", "ts"),
        ("string", "activity_id"),
        ("string", "scriptblock_id"),
        ("string", "scriptblock"),
        ("uint32[]", "event_record_ids"),
        ("uint32", "pid"),
        ("uint32", "tid"),
        ("uint32", "total_messages"),
        ("string", "user_sid"),
        ("boolean", "script_complete"),
        ("path", "script_path"),
    ],
)
ConsoleHostHistoryRecord = create_extended_descriptor([UserRecordDescriptorExtension])(
    "powershell/history",
    [
        ("datetime", "mtime"),
        ("varint", "order"),
        ("string", "command"),
        ("path", "source"),
    ],
)


class PowershellPlugin(Plugin):
    """Plugin for parsing Powershell Artifacts

    Currently implemented are parsing of Powershell 4104 EventLogs and
    """

    __namespace__ = "powershell"

    SCRIPTBLOCK_EVENTID = 4104
    LOGS_DIR_PATH = "sysvol/windows/system32/winevt/logs/"
    OPERATIONAL_LOG_PATH = "Microsoft-Windows-PowerShell%4Operational.evtx"
    PATHS = (
        "AppData/Roaming/Microsoft/Windows/PowerShell/psreadline",
        ".local/share/powershell/PSReadLine",
    )

    def __init__(self, target: Target):
        super().__init__(target)
        # Used in scriptblocks
        self.log_path = self.target.fs.path(self.LOGS_DIR_PATH + self.OPERATIONAL_LOG_PATH)

        # Used in powershell_history
        self._history = []

        for user_details in target.user_details.all_with_home():
            for ps_path in self.PATHS:
                history_path = user_details.home_path.joinpath(ps_path)
                for history_file in history_path.glob("*_history.txt"):
                    self._history.append((user_details.user, history_file))

    def check_compatible(self) -> None:
        if not any([self.log_path.exists(), self._history]):
            raise UnsupportedPluginError("No Powershell Artifcats were found!")

    def build_scriptblock(self, scriptblock_group: list[DynamicDescriptor]) -> PowershellScriptblockRecord:
        script_complete = True
        scriptblock_id = scriptblock_group[0].ScriptBlockId
        group_msg_total = int(scriptblock_group[0].MessageTotal)
        event_record_ids = [int(log.EventRecordID) for log in scriptblock_group]
        if len(scriptblock_group) < group_msg_total:
            self.target.log.warning("ScriptBlock with id %s is incomplete", scriptblock_id)
            script_complete = False

        full_script = "".join([log.ScriptBlockText for log in scriptblock_group])
        yield PowershellScriptblockRecord(
            ts=scriptblock_group[0].ts,
            activity_id=scriptblock_group[0].Correlation_ActivityID,
            scriptblock_id=scriptblock_id,
            scriptblock=full_script,
            event_record_ids=event_record_ids,
            pid=int(scriptblock_group[0].Execution_ProcessID),
            tid=int(scriptblock_group[0].Execution_ThreadID),
            total_messages=group_msg_total,
            user_sid=scriptblock_group[0].Security_UserID,
            script_complete=script_complete,
            script_path=scriptblock_group[0].Path,
            _target=self.target,
        )

    @export(record=PowershellScriptblockRecord)
    def scriptblocks(self) -> Iterator[PowershellScriptblockRecord]:
        """Parse PowerShell event log entries with ID 4104, which are generated by Script Block Logging.

        Script Block Logging is a PowerShell feature that logs the contents of all script blocks processed
        by the PowerShell engine, including commands, scripts, functions, and code blocks.
        These events are logged inWindows Event Log (Microsoft-Windows-PowerShell/Operational).
        """
        events = self.target.evtx(logs_dir=self.LOGS_DIR_PATH, log_file_glob=self.OPERATIONAL_LOG_PATH)

        """The executed Scriptblocks are broken to multiple events if the size of the block is too large.
        to get the entire script, the messages are grouped together and then combined to one record
        """
        scriptblock_group = []
        for event in events:
            if event.EventID == self.SCRIPTBLOCK_EVENTID:
                if event.MessageTotal == event.MessageNumber:
                    if not scriptblock_group:
                        scriptblock_group = [event]
                    yield from self.build_scriptblock(scriptblock_group)
                else:
                    scriptblock_group.append(event)

    @export(record=ConsoleHostHistoryRecord)
    def powershell_history(self) -> Iterator[ConsoleHostHistoryRecord]:
        """Return PowerShell command history for all users.

        The PowerShell ``ConsoleHost_history.txt`` file contains information about the commands executed with PowerShell in
        a terminal. No data is recorded from terminal-less PowerShell sessions. Commands are saved to disk after the process has completed.
        PSReadLine does not save commands containing 'password', 'asplaintext', 'token', 'apikey' or 'secret'.

        References:
            - https://0xdf.gitlab.io/2018/11/08/powershell-history-file.html
            - https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_history?view=powershell-7.3#order-of-commands-in-the-history
            - https://learn.microsoft.com/en-us/powershell/module/psreadline/about/about_psreadline?view=powershell-7.3#command-history
        """  # noqa E501

        for user, path in self._history:
            file_mtime = path.stat().st_mtime

            i = 0
            for line in path.open("r"):
                line = line.strip()
                if not line:
                    continue

                yield ConsoleHostHistoryRecord(
                    mtime=file_mtime,
                    command=line,
                    order=i,
                    source=path,
                    _target=self.target,
                    _user=user,
                )
                i += 1
